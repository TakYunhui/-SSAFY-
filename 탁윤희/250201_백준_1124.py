# 실버1. 언더프라임
# 언더프라임: 어떤 수를 소인수 분해해서 구한 소수의 목록 길이가 소수인 것
# a, b 범위 내 언더프라임 개수 구하기
# 2 <= a <= b <= 100,000
# 위 범위 안 소수 목록 list를 만들고, 소수 목록으로 주어진 a, b 범위 안 숫자들 나눠 언더프라임개수 만들기?
a, b = map(int, input().split())
# 소수 판별 및 소인수 분해 정보 계산 함수
def is_prime(n):
    # 소수 판별 : 2부터 루트n까지 n이 i로 나누어 떨어지면 소수가 아니라 판단
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            # 전역 리스트 d를 사용해 n의 소인수 개수 저장
            # d[n//i] : n을 i로 나눈 나머지 수의 소인수 개수
            # +1 : 현재 확인한 소인수(i)를 포함시키기 위해
            # ㄴ n 은  i * (n//i)이기 때문이다
            d[n] = d[n//i] + 1
            return False
    # 반복문을 다 돌고 n이 소수라면 반복문 내부에 한번도 걸리지 않았으므로 소수(자기 자신만이 소인수) 소인수 개수 1 선언
    d[n] = 1
    return True
# 전역 리스트 d 초기화 : 인덱스 n에 대하여 n의 소인수(중복 포함) 개수 저장 리스트
d = [0] * (b+1)
# res: 인덱스 n에 대해 n이 소수인지 여부 저장
res = [False] * (b+1)
# 2에서 b까지 " " 확인
for i in range(2, b+1):
    # 반환 값이 소수인지 아닌지 판별 + 함수 내부에서 d[i]에 i 소인수 분해 횟수 저장
    res[i] = is_prime(i)

result = 0
for i in range(a, b+1):
    # res[d[i]]: d[i]가 소수인지 여부 나타냄
    # d[i]가 소수면 res[d[i]]는 1로 반환
    # 그렇지 않으면 False 반환
    result += res[d[i]]
print(result)